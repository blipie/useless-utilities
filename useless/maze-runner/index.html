<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Runner - Advanced</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a202c;
            color: #a0aec0;
            overflow: hidden;
        }
        canvas {
            background-color: #2d3748;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .btn {
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 14px rgba(50,50,93,.1), 0 3px 6px rgba(0,0,0,.08);
        }
        .btn.active {
            border-color: #4299e1;
            background-color: #2b6cb0;
        }
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.7); /* Black w/ opacity */
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: #2d3748;
            padding: 2rem;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 0.5rem;
            text-align: center;
            animation: slide-in 0.3s ease-out;
        }
        @keyframes slide-in {
            from { transform: translateY(-30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <h1 class="text-4xl md:text-5xl text-white mb-4 tracking-wider">Maze Runner</h1>
    <p class="text-gray-400 mb-6">Use Arrow Keys for fluid movement. Reach the blue square!</p>

    <div class="flex flex-col md:flex-row items-center gap-8 w-full max-w-5xl">
        <!-- Game Canvas -->
        <div class="w-full md:w-auto flex justify-center">
            <canvas id="mazeCanvas"></canvas>
        </div>

        <!-- Game Info Panel -->
        <div class="w-full md:w-1/3 bg-gray-800 p-6 rounded-lg shadow-lg text-center md:text-left">
            <h2 class="text-2xl text-white mb-4">Difficulty</h2>
            <div class="flex justify-center md:justify-start gap-2 mb-6">
                <button id="difficultyStandard" class="btn active bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Standard</button>
                <button id="difficultyLSystem" class="btn bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">L-System</button>
            </div>
            
            <h2 class="text-2xl text-white mb-4">Stats</h2>
            <div class="mb-4">
                <p class="text-lg text-gray-400">Time</p>
                <p id="timer" class="text-3xl text-green-400">0.00</p>
            </div>
            <div class="mb-6">
                <p class="text-lg text-gray-400">Score</p>
                <p id="score" class="text-3xl text-yellow-400">0</p>
            </div>
            <button id="startButton" class="btn w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg text-xl">
                New Game
            </button>
        </div>
    </div>

    <!-- Win Modal -->
    <div id="winModal" class="modal">
        <div class="modal-content">
            <h2 id="winMessage" class="text-3xl text-green-400 mb-4">You Win!</h2>
            <p id="finalStats" class="text-xl text-white mb-6"></p>
            <button id="playAgainButton" class="btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg text-xl">
                Play Again
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elements
        const startButton = document.getElementById('startButton');
        const timerEl = document.getElementById('timer');
        const scoreEl = document.getElementById('score');
        const winModal = document.getElementById('winModal');
        const finalStats = document.getElementById('finalStats');
        const playAgainButton = document.getElementById('playAgainButton');
        const standardBtn = document.getElementById('difficultyStandard');
        const lSystemBtn = document.getElementById('difficultyLSystem');

        // Game State
        let maze, player, cellSize, mazeSize;
        let startTime, timerInterval;
        let gameActive = false;
        let difficulty = 'standard';
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

        function setupCanvas() {
            const containerWidth = canvas.parentElement.clientWidth;
            const containerHeight = window.innerHeight * 0.75;
            const size = Math.min(containerWidth, containerHeight, 600);
            canvas.width = size;
            canvas.height = size;
        }

        function init() {
            setupCanvas();
            mazeSize = difficulty === 'standard' ? 21 : 35; // L-system mazes can be larger
            cellSize = canvas.width / mazeSize;
            
            player = {
                x: cellSize * 1.5,
                y: cellSize * 1.5,
                size: cellSize * 0.6,
                speed: cellSize * 0.15,
                vx: 0,
                vy: 0
            };

            if (difficulty === 'standard') {
                maze = generateStandardMaze(mazeSize, mazeSize);
            } else {
                maze = generateLSystemMaze(mazeSize, mazeSize);
            }
            
            // Adjust player start for L-system which starts at (1,1)
            if (difficulty === 'l-system') {
                maze[1][1] = 0; // Ensure start is open
                player.x = cellSize * 1.5;
                player.y = cellSize * 1.5;
            } else {
                 maze[1][0] = 2; // Start
                 player.x = cellSize * 0.5;
                 player.y = cellSize * 1.5;
            }


            gameActive = true;
            resetTimer();
            startTimer();
            
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            gameLoop();
        }

        // --- Maze Generation ---

        // Standard Recursive Backtracking Maze
        function generateStandardMaze(width, height) {
            let maze = Array.from({ length: height }, () => Array(width).fill(1));
            
            function carve(x, y) {
                maze[y][x] = 0;
                const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                directions.sort(() => Math.random() - 0.5);

                for (let [dx, dy] of directions) {
                    const nx = x + dx * 2;
                    const ny = y + dy * 2;
                    if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && maze[ny][nx] === 1) {
                        maze[y + dy][x + dx] = 0;
                        carve(nx, ny);
                    }
                }
            }
            
            carve(1, 1);
            maze[height - 2][width - 1] = 3; // End
            return maze;
        }

        // L-System Based Maze
        function generateLSystemMaze(width, height) {
            let maze = Array.from({ length: height }, () => Array(width).fill(1));
            
            // 1. L-System Generation
            const lSystem = {
                axiom: 'F-F-F-F',
                rules: { 'F': 'F-F+F+FF-F-F+F' },
                angle: 90,
                iterations: 2,
            };

            let path = lSystem.axiom;
            for (let i = 0; i < lSystem.iterations; i++) {
                path = path.split('').map(char => lSystem.rules[char] || char).join('');
            }
            
            // 2. Turtle draws the L-system pattern
            let turtle = { x: 1, y: 1, angle: 0 };
            maze[turtle.y][turtle.x] = 0;

            for (const cmd of path) {
                if (cmd === 'F') {
                    const rad = turtle.angle * (Math.PI / 180);
                    const dx = Math.round(Math.cos(rad));
                    const dy = Math.round(Math.sin(rad));
                    for(let i = 0; i < 2; i++) { // Move two steps to create thicker paths
                        turtle.x += dx;
                        turtle.y += dy;
                        if (turtle.x > 0 && turtle.x < width - 1 && turtle.y > 0 && turtle.y < height - 1) {
                            maze[turtle.y][turtle.x] = 0;
                        }
                    }
                } else if (cmd === '+') {
                    turtle.angle = (turtle.angle + lSystem.angle) % 360;
                } else if (cmd === '-') {
                    turtle.angle = (turtle.angle - lSystem.angle + 360) % 360;
                }
            }

            // 3. Recursive block removal (ensure connectivity)
            // We run the standard algorithm on top to connect any isolated parts
            function connect(x, y) {
                 const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                 directions.sort(() => Math.random() - 0.5);
                 for (let [dx, dy] of directions) {
                    const nx = x + dx * 2;
                    const ny = y + dy * 2;
                    if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && maze[ny][nx] === 1) {
                         maze[y+dy][x+dx] = 0;
                         maze[ny][nx] = 0;
                         connect(nx, ny);
                    }
                 }
            }
            connect(1, 1);

            maze[height - 2][width - 1] = 3; // End
            return maze;
        }

        // --- Game Loop and Physics ---
        function gameLoop() {
            if (!gameActive) return;
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            // Update velocity based on keys pressed
            player.vx = 0;
            player.vy = 0;
            if (keys.ArrowUp) player.vy = -player.speed;
            if (keys.ArrowDown) player.vy = player.speed;
            if (keys.ArrowLeft) player.vx = -player.speed;
            if (keys.ArrowRight) player.vx = player.speed;

            // Collision detection
            let nextX = player.x + player.vx;
            let nextY = player.y + player.vy;

            // Check collision on X-axis
            if (!isColliding(nextX, player.y)) {
                player.x = nextX;
            }
            // Check collision on Y-axis
            if (!isColliding(player.x, nextY)) {
                player.y = nextY;
            }
            
            checkWinCondition();
        }
        
        function isColliding(px, py) {
            const halfSize = player.size / 2;
            const corners = [
                { x: px - halfSize, y: py - halfSize }, // Top-left
                { x: px + halfSize, y: py - halfSize }, // Top-right
                { x: px - halfSize, y: py + halfSize }, // Bottom-left
                { x: px + halfSize, y: py + halfSize }, // Bottom-right
            ];

            for (const corner of corners) {
                const gridX = Math.floor(corner.x / cellSize);
                const gridY = Math.floor(corner.y / cellSize);
                if (gridX < 0 || gridX >= mazeSize || gridY < 0 || gridY >= mazeSize || (maze[gridY] && maze[gridY][gridX] === 1)) {
                    return true; // Collision detected
                }
            }
            return false;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw maze
            for (let y = 0; y < mazeSize; y++) {
                for (let x = 0; x < mazeSize; x++) {
                    const cell = maze[y][x];
                    if (cell === 1) ctx.fillStyle = '#4a5568';
                    else if (cell === 2) ctx.fillStyle = '#48bb78'; // Start
                    else if (cell === 3) ctx.fillStyle = '#4299e1'; // End
                    else ctx.fillStyle = '#2d3748'; // Path
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
            // Draw player
            ctx.fillStyle = '#f56565';
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.size / 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function checkWinCondition() {
            const gridX = Math.floor(player.x / cellSize);
            const gridY = Math.floor(player.y / cellSize);
            if (maze[gridY] && maze[gridY][gridX] === 3) {
                gameActive = false;
                stopTimer();
                const timeTaken = (Date.now() - startTime) / 1000;
                const score = Math.max(0, Math.floor(100000 / timeTaken));
                scoreEl.textContent = score;
                finalStats.textContent = `Time: ${timeTaken.toFixed(2)}s - Score: ${score}`;
                winModal.style.display = "flex";
            }
        }

        // --- Event Handlers & Timers ---
        function handleKeyDown(e) {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
                e.preventDefault();
            }
        }
        function handleKeyUp(e) {
             if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
                e.preventDefault();
            }
        }

        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(() => {
                const elapsedTime = (Date.now() - startTime) / 1000;
                timerEl.textContent = elapsedTime.toFixed(2);
            }, 100);
        }

        function stopTimer() { clearInterval(timerInterval); }
        function resetTimer() {
            stopTimer();
            timerEl.textContent = '0.00';
            scoreEl.textContent = '0';
        }

        function startNewGame() {
            winModal.style.display = "none";
            gameActive = false;
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('keyup', handleKeyUp);
            init();
        }

        // --- UI Listeners ---
        startButton.addEventListener('click', startNewGame);
        playAgainButton.addEventListener('click', startNewGame);
        
        standardBtn.addEventListener('click', () => {
            difficulty = 'standard';
            standardBtn.classList.add('active');
            lSystemBtn.classList.remove('active');
        });

        lSystemBtn.addEventListener('click', () => {
            difficulty = 'l-system';
            lSystemBtn.classList.add('active');
            standardBtn.classList.remove('active');
        });

        window.addEventListener('load', () => {
            setupCanvas();
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.font = "16px 'Press Start 2P'";
            ctx.fillText('Select Difficulty & Click "New Game"', canvas.width / 2, canvas.height / 2);
        });
        
        window.addEventListener('resize', () => {
            if (!gameActive) {
                setupCanvas();
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = "16px 'Press Start 2P'";
                ctx.fillText('Select Difficulty & Click "New Game"', canvas.width / 2, canvas.height / 2);
            } else {
                setupCanvas();
                cellSize = canvas.width / mazeSize;
                player.size = cellSize * 0.6;
                player.speed = cellSize * 0.15;
                // Recalculate player pixel position to keep it in the same cell
                const gridX = Math.floor(player.x / (canvas.width / mazeSize));
                const gridY = Math.floor(player.y / (canvas.height / mazeSize));
                player.x = (gridX + 0.5) * cellSize;
                player.y = (gridY + 0.5) * cellSize;
            }
        });
    </script>
</body>
</html>
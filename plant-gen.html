<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual L-System Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100vh;
            overflow: hidden;
        }
        body {
            font-family: 'Inter', sans-serif;
        }
        .scrollable-panel {
            overflow-y: auto;
        }
        .mono-font {
            font-family: 'Roboto Mono', monospace;
        }
        canvas {
            border: 1px solid #e2e8f0;
            background-color: #f8fafc;
        }
        .rule-token {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.25rem 0.5rem;
            margin: 0.125rem;
            border-radius: 0.375rem;
            font-weight: 500;
            font-size: 0.875rem;
            cursor: default;
            transition: background-color 0.2s;
        }
        [contenteditable]:focus {
            outline: none;
        }
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }
        input[type=number] {
            -moz-appearance: textfield;
        }
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: 2px solid #e2e8f0;
            border-radius: 50%;
        }
        .collapsible-content {
            display: none;
            transition: max-height 0.3s ease-in-out;
            overflow: hidden;
        }
        .collapsible-arrow {
            transition: transform 0.3s ease-in-out;
        }
        /* Toggle Switch */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #3b82f6;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #3b82f6;
        }
        .pulse {
            animation: pulse-animation 1s infinite;
        }
        @keyframes pulse-animation {
            0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
            100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 flex flex-col">

    <div class="container mx-auto p-4 lg:p-8 flex flex-col flex-grow min-h-0">
        <header class="text-center mb-8 flex-shrink-0 flex items-center justify-center relative">
            <h1 class="text-4xl font-bold text-slate-900">Visual L-System Generator</h1>
            <p class="text-slate-600 mt-2">Visually build rules to create fractal patterns.</p>
            <button id="home-btn" class="absolute left-0 top-1/2 -translate-y-1/2 bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors duration-200">
                Home
            </button>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-12 gap-8 flex-grow min-h-0">
            
            <!-- SECTION A: Core Creation Tools -->
            <div class="lg:col-span-3 bg-white p-6 rounded-2xl shadow-lg border border-slate-200 flex flex-col">
                <h2 class="text-2xl font-bold mb-6 border-b pb-3 flex-shrink-0">Creation Tools</h2>
                <div class="scrollable-panel flex-grow pr-2 min-h-0">
                    <div class="space-y-6">
                        <!-- Preset Dropdown -->
                        <div>
                            <label for="preset-select" class="block text-sm font-medium text-slate-700 mb-2">Load Preset</label>
                            <select id="preset-select" class="w-full p-2 border border-slate-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-200">
                                <option value="simple-tree">Simple Tree</option>
                                <option value="simple-plant">Simple Plant</option>
                                <option value="bushy-tree">Bushy Tree</option>
                                <option value="weed">Weed</option>
                                <option value="koch-snowflake">Koch Snowflake</option>
                                <option value="sierpinski-gasket">Sierpinski Gasket</option>
                                <option value="dragon-curve">Dragon Curve</option>
                                <option value="custom">Custom (Clear All)</option>
                            </select>
                        </div>
                        <!-- Axiom Display -->
                        <div>
                            <label class="block text-sm font-medium text-slate-700 mb-2">Axiom (Start)</label>
                            <div id="axiom-list-container">
                                <!-- Axiom display item will be dynamically inserted here -->
                            </div>
                        </div>

                        <!-- Rule List Display -->
                        <div>
                            <label class="block text-sm font-medium text-slate-700 mb-2">Rules</label>
                            <div id="rule-list-container" class="space-y-2">
                               <!-- Rule list items will be dynamically inserted here -->
                            </div>
                            <button id="add-rule-btn" class="mt-4 w-full bg-blue-100 text-blue-800 font-semibold py-2 px-4 rounded-lg hover:bg-blue-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all duration-200">
                                + Add New Rule
                            </button>
                        </div>
                    </div>
                </div>
                 <!-- Action Buttons (Fixed at bottom) -->
                <div class="grid grid-cols-3 gap-2 pt-4 border-t mt-auto flex-shrink-0">
                     <button id="generate-btn" class="col-span-3 sm:col-span-1 bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-all duration-200 shadow-md hover:shadow-lg">
                        Generate
                    </button>
                    <button id="fit-btn" class="col-span-3 sm:col-span-1 bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-all duration-200 shadow-md hover:shadow-lg">
                        Fit to View
                    </button>
                    <button id="clear-btn" class="col-span-3 sm:col-span-1 bg-slate-200 text-slate-700 font-bold py-3 px-4 rounded-lg hover:bg-slate-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-400 transition-all duration-200">
                        Clear
                    </button>
                </div>
            </div>

            <!-- SECTION B: Canvas -->
            <div class="lg:col-span-6 bg-white rounded-2xl shadow-lg border border-slate-200 flex flex-col">
                <canvas id="lsystem-canvas" class="w-full flex-grow rounded-t-2xl min-h-0"></canvas>
                <div class="p-4 bg-slate-100 rounded-b-2xl flex-shrink-0">
                     <h3 class="text-sm font-semibold text-slate-600">Generated String:</h3>
                     <div class="mt-2 p-3 bg-slate-800 text-slate-100 rounded-md max-h-24 overflow-y-auto mono-font text-xs">
                        <code id="output-string">Press "Generate" to create an L-System.</code>
                     </div>
                </div>
            </div>

            <!-- SECTION C: Fine-Tuning Controls -->
            <div class="lg:col-span-3 bg-white p-6 rounded-2xl shadow-lg border border-slate-200 flex flex-col">
                <h2 class="text-2xl font-bold mb-6 border-b pb-3 flex-shrink-0">Drawing Settings</h2>
                    <div class="scrollable-panel flex-grow pr-2 min-h-0">
                        <div class="space-y-6">
                            <!-- Auto-Generate Toggle -->
                            <div class="flex items-center justify-between">
                                <label for="auto-generate-toggle" class="text-sm font-medium text-slate-700">Auto-Generate</label>
                                <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                                    <input type="checkbox" name="auto-generate-toggle" id="auto-generate-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer" checked/>
                                    <label for="auto-generate-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"></label>
                                </div>
                            </div>
                            
                            <!-- Iterations, Angle, Length -->
                            <div class="pt-4 border-t">
                                <div>
                                    <div class="flex justify-between items-center mb-1">
                                        <label for="iterations" class="text-sm font-medium text-slate-700">Iterations</label>
                                        <input type="number" id="iterations-number" value="5" min="0" max="8" class="w-20 p-1 text-center border border-slate-300 rounded-md mono-font">
                                    </div>
                                    <input type="range" id="iterations" min="0" max="8" value="5" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                                </div>
                                <div>
                                    <div class="flex justify-between items-center mb-1">
                                        <label for="angle" class="text-sm font-medium text-slate-700">Angle</label>
                                        <input type="number" id="angle-number" value="25" min="0" max="180" class="w-20 p-1 text-center border border-slate-300 rounded-md mono-font">
                                    </div>
                                    <input type="range" id="angle" min="0" max="180" value="25" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                                </div>
                                <div>
                                   <div class="flex justify-between items-center mb-1">
                                        <label for="length" class="text-sm font-medium text-slate-700">Line Length</label>
                                        <input type="number" id="length-number" value="5" min="1" max="50" class="w-20 p-1 text-center border border-slate-300 rounded-md mono-font">
                                    </div>
                                    <input type="range" id="length" min="1" max="50" value="5" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                                </div>
                            </div>
                            
                            <!-- Color Controls -->
                            <div class="pt-4 border-t">
                                <button class="w-full text-left collapsible-header">
                                    <h3 class="text-lg font-semibold text-slate-800 flex justify-between items-center">
                                        <span>Colors</span>
                                        <svg class="collapsible-arrow w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                                    </h3>
                                </button>
                                <div class="collapsible-content mt-3">
                                    <div class="flex justify-around items-center">
                                        <div class="text-center">
                                            <label for="line-color" class="block text-sm font-medium text-slate-700 mb-2">Line Color</label>
                                            <input type="color" id="line-color" value="#1e2b3b">
                                            <button class="reset-color-btn text-xs text-slate-500 hover:text-blue-600 mt-1" data-target="line-color" data-default="#1e2b3b">Reset</button>
                                        </div>
                                        <div class="text-center">
                                            <label for="shape-color" class="block text-sm font-medium text-slate-700 mb-2">Shape Color</label>
                                            <input type="color" id="shape-color" value="#ef4444">
                                            <button class="reset-color-btn text-xs text-slate-500 hover:text-blue-600 mt-1" data-target="shape-color" data-default="#ef4444">Reset</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Start Position Variables -->
                            <div class="pt-4 border-t">
                                 <button class="w-full text-left collapsible-header">
                                    <h3 class="text-lg font-semibold text-slate-800 flex justify-between items-center">
                                        <span>Initial State</span>
                                        <svg class="collapsible-arrow w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                                    </h3>
                                </button>
                                <div class="collapsible-content mt-3 space-y-4">
                                    <div>
                                        <label for="startX" class="block text-sm font-medium text-slate-700 mb-1">Start X: <span id="startX-value" class="font-bold text-blue-600">50</span>%</label>
                                        <input type="range" id="startX" min="0" max="100" value="50" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                                    </div>
                                    <div>
                                        <label for="startY" class="block text-sm font-medium text-slate-700 mb-1">Start Y: <span id="startY-value" class="font-bold text-blue-600">100</span>%</label>
                                        <input type="range" id="startY" min="0" max="100" value="100" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                                    </div>
                                    <div>
                                        <label for="startAngle" class="block text-sm font-medium text-slate-700 mb-1">Start Angle: <span id="startAngle-value" class="font-bold text-blue-600">-90</span>Â°</label>
                                        <input type="range" id="startAngle" min="-180" max="180" value="-90" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
            </div>
        </main>
    </div>

    <!-- Rule Editor Modal -->
    <div id="rule-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4">
        <div class="bg-white rounded-2xl shadow-xl p-6 w-full max-w-lg">
            <h3 id="modal-title" class="text-xl font-bold mb-4">Edit Rule</h3>
            <div class="space-y-4">
                <div id="modal-variable-container" class="flex items-center gap-2">
                    <label class="font-medium">Replace</label>
                    <input type="text" id="modal-variable-input" maxlength="1" class="mono-font w-12 p-1 text-center border border-slate-300 rounded-md">
                    <label class="font-medium">with:</label>
                </div>
                <div id="modal-body-display" class="min-h-[40px] bg-white border border-slate-300 rounded-md p-1 flex flex-wrap items-center" contenteditable="true"></div>
                <div id="modal-controls" class="grid grid-cols-4 gap-2 text-sm">
                    <button data-action="F" class="bg-slate-200 hover:bg-slate-300 p-1 rounded">Grow (F)</button>
                    <button data-action="[" class="bg-slate-200 hover:bg-slate-300 p-1 rounded">Branch [</button>
                    <button data-action="]" class="bg-slate-200 hover:bg-slate-300 p-1 rounded">Branch ]</button>
                    <button data-action="backspace" class="bg-red-200 hover:bg-red-300 text-red-800 p-1 rounded">Backspace</button>
                    <button data-action="+" class="bg-slate-200 hover:bg-slate-300 p-1 rounded">Turn +</button>
                    <button data-action="-" class="bg-slate-200 hover:bg-slate-300 p-1 rounded">Turn -</button>
                    <select class="modal-shape-select bg-slate-200 hover:bg-slate-300 p-1 rounded col-span-2">
                        <option value="">Add Shape...</option>
                        <option value="O">Circle (O)</option>
                        <option value="S">Square (S)</option>
                        <option value="T">Triangle (T)</option>
                        <option value="D">Diamond (D)</option>
                        <option value="W">Star (W)</option>
                        <option value="L">Leaf (L)</option>
                        <option value="M">Lobed Leaf (M)</option>
                    </select>
                    <div class="flex items-center col-span-4 gap-1">
                        <input type="text" placeholder="Var" class="modal-variable-input-add mono-font w-12 p-1 text-center border border-slate-300 rounded-md" maxlength="1">
                        <button class="modal-add-variable-btn bg-blue-200 hover:bg-blue-300 p-1 rounded w-full">Add Var</button>
                    </div>
                </div>
            </div>
            <div class="flex justify-end gap-4 mt-6">
                <button id="modal-cancel-btn" class="bg-slate-200 text-slate-800 font-semibold py-2 px-4 rounded-lg hover:bg-slate-300">Cancel</button>
                <button id="modal-save-btn" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700">Save Rule</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Element References ---
            const canvas = document.getElementById('lsystem-canvas');
            const ctx = canvas.getContext('2d');
            const presetSelect = document.getElementById('preset-select');
            const axiomListContainer = document.getElementById('axiom-list-container');
            const iterationsInput = document.getElementById('iterations');
            const iterationsNumber = document.getElementById('iterations-number');
            const angleInput = document.getElementById('angle');
            const angleNumber = document.getElementById('angle-number');
            const lengthInput = document.getElementById('length');
            const lengthNumber = document.getElementById('length-number');
            const lineColorInput = document.getElementById('line-color');
            const shapeColorInput = document.getElementById('shape-color');
            const startXInput = document.getElementById('startX');
            const startYInput = document.getElementById('startY');
            const startAngleInput = document.getElementById('startAngle');
            const startXValue = document.getElementById('startX-value');
            const startYValue = document.getElementById('startY-value');
            const startAngleValue = document.getElementById('startAngle-value');
            const generateBtn = document.getElementById('generate-btn');
            const fitBtn = document.getElementById('fit-btn');
            const clearBtn = document.getElementById('clear-btn');
            const outputStringEl = document.getElementById('output-string');
            const ruleListContainer = document.getElementById('rule-list-container');
            const addRuleBtn = document.getElementById('add-rule-btn');
            const autoGenerateToggle = document.getElementById('auto-generate-toggle');

            // Modal elements
            const ruleModal = document.getElementById('rule-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalVariableContainer = document.getElementById('modal-variable-container');
            const modalVariableInput = document.getElementById('modal-variable-input');
            const modalBodyDisplay = document.getElementById('modal-body-display');
            const modalControls = document.getElementById('modal-controls');
            const modalCancelBtn = document.getElementById('modal-cancel-btn');
            const modalSaveBtn = document.getElementById('modal-save-btn');
            const homeBtn = document.getElementById('home-btn');

            // --- State Management ---
            let currentSystemString = '';
            let lastDrawParams = {};
            let currentlyEditingRuleId = null;

            // --- L-System Presets ---
            const presets = {
                'simple-tree': {
                    axiom: 'A',
                    rules: [{ variable: 'A', body: 'F[+A][-A]FL' }, { variable: 'F', body: 'FF' }],
                    settings: { iterations: 5, angle: 25, length: 5, startX: 50, startY: 100, startAngle: -90, lineColor: '#1e2b3b', shapeColor: '#ef4444' }
                },
                'simple-plant': {
                    axiom: 'X',
                    rules: [{ variable: 'X', body: 'F-[[X]+X]+F[+FX]-X' }, { variable: 'F', body: 'FF' }],
                    settings: { iterations: 4, angle: 22.5, length: 5, startX: 50, startY: 100, startAngle: -90, lineColor: '#1e2b3b', shapeColor: '#ef4444' }
                },
                'bushy-tree': {
                    axiom: 'F',
                    rules: [{ variable: 'F', body: 'FF-[-F+F+F]+[+F-F-F]' }],
                    settings: { iterations: 4, angle: 22.5, length: 3, startX: 50, startY: 100, startAngle: -90, lineColor: '#1e2b3b', shapeColor: '#ef4444' }
                },
                'weed': {
                    axiom: 'F',
                    rules: [{ variable: 'F', body: 'F[+F]F[-F]F' }],
                    settings: { iterations: 5, angle: 25.7, length: 3, startX: 50, startY: 100, startAngle: -90, lineColor: '#1e2b3b', shapeColor: '#ef4444' }
                },
                'koch-snowflake': {
                    axiom: 'F++F++F',
                    rules: [{ variable: 'F', body: 'F-F++F-F' }],
                    settings: { iterations: 4, angle: 60, length: 5, startX: 5, startY: 90, startAngle: 0, lineColor: '#1e2b3b', shapeColor: '#ef4444' }
                },
                'sierpinski-gasket': {
                    axiom: 'A',
                    rules: [{ variable: 'A', body: '+B-A-B+' }, { variable: 'B', body: '-A+B+A-' }],
                    settings: { iterations: 6, angle: 60, length: 5, startX: 50, startY: 100, startAngle: 0, lineColor: '#1e2b3b', shapeColor: '#ef4444' }
                },
                'dragon-curve': {
                    axiom: 'FX',
                    rules: [{ variable: 'X', body: 'X+YF+' }, { variable: 'Y', body: '-FX-Y' }],
                    settings: { iterations: 10, angle: 90, length: 5, startX: 50, startY: 50, startAngle: 0, lineColor: '#1e2b3b', shapeColor: '#ef4444' }
                }
            };

            // --- Debounce for Auto-Generate ---
            let debounceTimer;
            const debounce = (func, delay) => {
                return function(...args) {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => {
                        func.apply(this, args);
                    }, delay);
                };
            };
            
            const handleAutoGenerate = debounce(() => {
                if (autoGenerateToggle.checked) {
                    generateAndDraw();
                }
            }, 400);

            // --- Generic Token Rendering ---
            const renderTokens = (displayElement, bodyString) => {
                displayElement.innerHTML = '';
                for (const char of bodyString) {
                    const token = document.createElement('span');
                    token.textContent = char;
                    token.className = 'rule-token';
                    let color = 'bg-slate-200 text-slate-800'; // Default
                    if (/[A-Z]/.test(char) && 'FG'.indexOf(char) === -1 && 'OSTDWLM'.indexOf(char) === -1) {
                        color = 'bg-blue-200 text-blue-800'; // Variable
                    } else if ('FG'.includes(char)) {
                        color = 'bg-green-200 text-green-800'; // Grow
                    } else if ('+-'.includes(char)) {
                        color = 'bg-yellow-200 text-yellow-800'; // Turn
                    } else if ('[]'.includes(char)) {
                        color = 'bg-purple-200 text-purple-800'; // Branch
                    } else if ('OSTDWLM'.includes(char)) {
                        color = 'bg-red-200 text-red-800'; // Shape
                    }
                    token.classList.add(...color.split(' '));
                    displayElement.appendChild(token);
                }
            };
            
            // --- Paste Handler ---
            const handlePaste = (event, displayElement, updateCallback) => {
                event.preventDefault();
                const pastedText = event.clipboardData.getData('text/plain');
                const sanitizedText = pastedText.replace(/[^A-ZFG+\-\[\]OSTDWLM]/gi, '').toUpperCase();
                updateCallback(displayElement.dataset.body + sanitizedText);
            };

            // --- Axiom Display Logic ---
            const createAxiomDisplay = (body) => {
                axiomListContainer.innerHTML = ''; // Clear previous
                const axiomDiv = document.createElement('div');
                axiomDiv.id = 'axiom-display-item';
                axiomDiv.className = 'rule-display-item bg-slate-50 p-2 rounded-lg border border-slate-200 flex items-center justify-between';
                axiomDiv.dataset.body = body;

                const content = document.createElement('div');
                content.className = 'flex items-center gap-2 overflow-hidden';
                
                const bodyPreview = document.createElement('div');
                bodyPreview.className = 'flex-nowrap flex overflow-hidden whitespace-nowrap';
                renderTokens(bodyPreview, body);
                content.appendChild(bodyPreview);

                const editBtn = document.createElement('button');
                editBtn.className = 'edit-axiom-btn text-slate-500 hover:text-blue-600 ml-auto';
                editBtn.textContent = 'Edit';
                editBtn.addEventListener('click', () => {
                    openRuleModal({ id: 'axiom-display-item', body: axiomDiv.dataset.body });
                });

                axiomDiv.appendChild(content);
                axiomDiv.appendChild(editBtn);
                axiomListContainer.appendChild(axiomDiv);
            };

            // --- Rule Modal Logic ---
            const openRuleModal = ({ id = null, variable = '', body = '' } = {}) => {
                currentlyEditingRuleId = id;

                if (id === 'axiom-display-item') {
                    modalTitle.textContent = 'Edit Axiom';
                    modalVariableContainer.classList.add('hidden');
                } else {
                    modalTitle.textContent = id ? 'Edit Rule' : 'Add New Rule';
                    modalVariableContainer.classList.remove('hidden');
                    modalVariableInput.value = variable;
                }
                
                const updateModalBody = (newBody) => {
                    modalBodyDisplay.dataset.body = newBody;
                    renderTokens(modalBodyDisplay, newBody);
                };
                
                updateModalBody(body);
                ruleModal.classList.remove('hidden');
                ruleModal.classList.add('flex');
            };

            const closeRuleModal = () => {
                ruleModal.classList.add('hidden');
                ruleModal.classList.remove('flex');
                currentlyEditingRuleId = null;
            };

            modalControls.querySelectorAll('button[data-action]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const action = btn.dataset.action;
                    let currentBody = modalBodyDisplay.dataset.body;
                    if (action === 'backspace') {
                        currentBody = currentBody.slice(0, -1);
                    } else {
                        currentBody += action;
                    }
                    modalBodyDisplay.dataset.body = currentBody;
                    renderTokens(modalBodyDisplay, currentBody);
                });
            });

            modalControls.querySelector('.modal-add-variable-btn').addEventListener('click', () => {
                const varInput = modalControls.querySelector('.modal-variable-input-add');
                if (varInput.value) {
                    let currentBody = modalBodyDisplay.dataset.body;
                    currentBody += varInput.value.toUpperCase();
                    modalBodyDisplay.dataset.body = currentBody;
                    renderTokens(modalBodyDisplay, currentBody);
                    varInput.value = '';
                }
            });

            modalControls.querySelector('.modal-shape-select').addEventListener('change', (e) => {
                if (e.target.value) {
                    let currentBody = modalBodyDisplay.dataset.body;
                    currentBody += e.target.value;
                    modalBodyDisplay.dataset.body = currentBody;
                    renderTokens(modalBodyDisplay, currentBody);
                    e.target.value = '';
                }
            });
            
            modalBodyDisplay.addEventListener('paste', (e) => handlePaste(e, modalBodyDisplay, (newBody) => {
                modalBodyDisplay.dataset.body = newBody;
                renderTokens(modalBodyDisplay, newBody);
            }));

            modalCancelBtn.addEventListener('click', closeRuleModal);

            // --- Rule List Display Logic ---
            const createRuleDisplay = (id, variable, body) => {
                const ruleDiv = document.createElement('div');
                ruleDiv.id = id;
                ruleDiv.className = 'rule-display-item bg-slate-50 p-2 rounded-lg border border-slate-200 flex items-center justify-between';
                ruleDiv.dataset.variable = variable;
                ruleDiv.dataset.body = body;

                const content = document.createElement('div');
                content.className = 'flex items-center gap-2 overflow-hidden';
                content.innerHTML = `<span class="font-bold mono-font text-blue-600">${variable}</span> <span class="text-slate-400">&rarr;</span>`;
                
                const bodyPreview = document.createElement('div');
                bodyPreview.className = 'flex-nowrap flex overflow-hidden whitespace-nowrap';
                renderTokens(bodyPreview, body);
                content.appendChild(bodyPreview);

                const buttons = document.createElement('div');
                buttons.className = 'flex items-center gap-2 flex-shrink-0 ml-2';
                buttons.innerHTML = `
                    <button class="edit-rule-btn text-slate-500 hover:text-blue-600">Edit</button>
                    <button class="delete-rule-btn text-slate-500 hover:text-red-600 font-bold">&times;</button>
                `;
                
                buttons.querySelector('.edit-rule-btn').addEventListener('click', () => {
                    openRuleModal({ id, variable: ruleDiv.dataset.variable, body: ruleDiv.dataset.body });
                });
                buttons.querySelector('.delete-rule-btn').addEventListener('click', () => {
                    ruleDiv.remove();
                    handleAutoGenerate();
                });

                ruleDiv.appendChild(content);
                ruleDiv.appendChild(buttons);
                ruleListContainer.appendChild(ruleDiv);
            };

            modalSaveBtn.addEventListener('click', () => {
                const body = modalBodyDisplay.dataset.body;
                
                if (currentlyEditingRuleId === 'axiom-display-item') {
                    createAxiomDisplay(body);
                } else {
                    const variable = modalVariableInput.value.toUpperCase();
                    if (!variable) return;

                    if (currentlyEditingRuleId) {
                        const ruleDiv = document.getElementById(currentlyEditingRuleId);
                        ruleDiv.dataset.variable = variable;
                        ruleDiv.dataset.body = body;
                        ruleDiv.querySelector('.font-bold').textContent = variable;
                        renderTokens(ruleDiv.querySelector('.flex-nowrap'), body);
                    } else {
                        const id = `rule-${Date.now()}`;
                        createRuleDisplay(id, variable, body);
                    }
                }
                closeRuleModal();
                handleAutoGenerate();
            });

            addRuleBtn.addEventListener('click', () => openRuleModal());
            
            // --- L-System Logic ---
            function parseRules() {
                const rules = {};
                document.querySelectorAll('.rule-display-item').forEach(item => {
                    if (item.dataset.variable) {
                        rules[item.dataset.variable] = item.dataset.body;
                    }
                });
                return rules;
            }

            function generateLSystemString() {
                const axiomEl = document.getElementById('axiom-list-container').querySelector('[id^="axiom"]');
                if (!axiomEl) return '';
                const axiom = axiomEl.dataset.body;
                const iterations = parseInt(iterationsInput.value, 10);
                const rules = parseRules();
                let currentString = axiom;
                for (let i = 0; i < iterations; i++) {
                    let nextString = '';
                    for (const char of currentString) {
                        nextString += rules[char] || char;
                    }
                    currentString = nextString;
                }
                currentSystemString = currentString;
                const displayString = currentSystemString.length > 5000 
                    ? currentSystemString.substring(0, 5000) + '... (truncated)'
                    : currentSystemString;
                outputStringEl.textContent = displayString;
                return currentSystemString;
            }
            
            function getDrawingBounds(systemString) {
                if (!systemString) return null;
                const angle = parseInt(angleInput.value, 10) * (Math.PI / 180);
                const length = 1;
                const stateStack = [];
                const startAngle = parseFloat(startAngleInput.value) * (Math.PI / 180);
                let turtle = { x: 0, y: 0, angle: startAngle };
                let bounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };
                const shapeRadius = (1 * 1.5) / 2; // Normalized shape radius

                for (const command of systemString) {
                    switch (command) {
                        case 'F': case 'G':
                            turtle.x += length * Math.cos(turtle.angle);
                            turtle.y += length * Math.sin(turtle.angle);
                            bounds.minX = Math.min(bounds.minX, turtle.x);
                            bounds.maxX = Math.max(bounds.maxX, turtle.x);
                            bounds.minY = Math.min(bounds.minY, turtle.y);
                            bounds.maxY = Math.max(bounds.maxY, turtle.y);
                            break;
                        case 'f':
                            turtle.x += length * Math.cos(turtle.angle);
                            turtle.y += length * Math.sin(turtle.angle);
                            break;
                        case '+': turtle.angle += angle; break;
                        case '-': turtle.angle -= angle; break;
                        case '[': stateStack.push({ ...turtle }); break;
                        case ']':
                            const poppedState = stateStack.pop();
                            if (poppedState) turtle = poppedState;
                            break;
                        case 'O': case 'S': case 'T': case 'D': case 'W': case 'L': case 'M':
                            bounds.minX = Math.min(bounds.minX, turtle.x - shapeRadius);
                            bounds.maxX = Math.max(bounds.maxX, turtle.x + shapeRadius);
                            bounds.minY = Math.min(bounds.minY, turtle.y - shapeRadius);
                            bounds.maxY = Math.max(bounds.maxY, turtle.y + shapeRadius);
                            break;
                    }
                }
                return bounds;
            }
            
            function renderLSystem(params) {
                const { systemString, length, startX, startY, startAngle, turnAngle, lineColor, shapeColor } = params;
                const stateStack = [];
                
                // Clear and reset canvas for a fresh drawing
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = 1.5;
                ctx.lineCap = 'round';
                
                let turtle = { x: startX, y: startY, angle: startAngle };
                ctx.beginPath();
                ctx.moveTo(turtle.x, turtle.y);

                for (let i = 0; i < systemString.length; i++) {
                    const command = systemString[i];
                    switch (command) {
                        case 'F': case 'G':
                            turtle.x += length * Math.cos(turtle.angle);
                            turtle.y += length * Math.sin(turtle.angle);
                            ctx.lineTo(turtle.x, turtle.y);
                            break;
                        case 'f':
                            turtle.x += length * Math.cos(turtle.angle);
                            turtle.y += length * Math.sin(turtle.angle);
                            ctx.moveTo(turtle.x, turtle.y);
                            break;
                        case '+': turtle.angle += turnAngle; break;
                        case '-': turtle.angle -= turnAngle; break;
                        case '[': stateStack.push({ ...turtle }); break;
                        case ']':
                            const poppedState = stateStack.pop();
                            if (poppedState) {
                                turtle = poppedState;
                                ctx.moveTo(turtle.x, turtle.y);
                            }
                            break;
                        case 'O': case 'S': case 'T': case 'D': case 'W': case 'L': case 'M':
                            ctx.stroke();
                            ctx.save();
                            ctx.fillStyle = shapeColor;
                            const shapeSize = length * 1.5;

                            ctx.translate(turtle.x, turtle.y);
                            ctx.rotate(turtle.angle + Math.PI / 2); // Orient shape with turtle
                            
                            if (command === 'O') {
                                ctx.beginPath();
                                ctx.arc(0, 0, shapeSize / 2, 0, 2 * Math.PI);
                                ctx.fill();
                            } else if (command === 'S') {
                                ctx.fillRect(-shapeSize/2, -shapeSize/2, shapeSize, shapeSize);
                            } else if (command === 'T') {
                                const h = (Math.sqrt(3)/2) * shapeSize;
                                ctx.beginPath();
                                ctx.moveTo(0, -(2/3)*h);
                                ctx.lineTo(-shapeSize/2, (1/3)*h);
                                ctx.lineTo(shapeSize/2, (1/3)*h);
                                ctx.closePath();
                                ctx.fill();
                            } else if (command === 'D') {
                                const d_half = shapeSize / 2;
                                ctx.beginPath();
                                ctx.moveTo(0, -d_half);
                                ctx.lineTo(d_half, 0);
                                ctx.lineTo(0, d_half);
                                ctx.lineTo(-d_half, 0);
                                ctx.closePath();
                                ctx.fill();
                            } else if (command === 'W') {
                                const spikes = 5, r0 = shapeSize/2, r1 = shapeSize/4;
                                let rot = Math.PI/2*3, x = 0, y = 0, step = Math.PI/spikes;
                                ctx.beginPath();
                                ctx.moveTo(0, -r0);
                                for (let i = 0; i < spikes; i++) {
                                    x = Math.cos(rot) * r0;
                                    y = Math.sin(rot) * r0;
                                    ctx.lineTo(x, y);
                                    rot += step;
                                    x = Math.cos(rot) * r1;
                                    y = Math.sin(rot) * r1;
                                    ctx.lineTo(x, y);
                                    rot += step;
                                }
                                ctx.closePath();
                                ctx.fill();
                            } else if (command === 'L') {
                                const leafLength = shapeSize * 1.2;
                                const leafWidth = shapeSize / 2;
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.quadraticCurveTo(leafWidth, -leafLength / 2, 0, -leafLength);
                                ctx.quadraticCurveTo(-leafWidth, -leafLength / 2, 0, 0);
                                ctx.fill();
                            } else if (command === 'M') {
                                const size = shapeSize;
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(-size * 0.1, -size * 0.2);
                                ctx.lineTo(-size * 0.4, -size * 0.3);
                                ctx.lineTo(-size * 0.3, -size * 0.5);
                                ctx.lineTo(-size * 0.5, -size * 0.6);
                                ctx.lineTo(0, -size);
                                ctx.lineTo(size * 0.5, -size * 0.6);
                                ctx.lineTo(size * 0.3, -size * 0.5);
                                ctx.lineTo(size * 0.4, -size * 0.3);
                                ctx.lineTo(size * 0.1, -size * 0.2);
                                ctx.closePath();
                                ctx.fill();
                            }
                            ctx.restore();
                            ctx.beginPath();
                            ctx.moveTo(turtle.x, turtle.y);
                            break;
                    }
                }
                ctx.stroke();
            }
            
            function generateAndDraw() {
                const newString = generateLSystemString();
                if (!newString) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    lastDrawParams = {};
                    return;
                }
                
                drawingBounds = getDrawingBounds(newString);
                const params = getDrawParameters();
                let finalParams;

                if (drawingBounds && (drawingBounds.maxX - drawingBounds.minX) > 0 && (drawingBounds.maxY - drawingBounds.minY) > 0) {
                    const drawingWidth = drawingBounds.maxX - drawingBounds.minX;
                    const drawingHeight = drawingBounds.maxY - drawingBounds.minY;
                    const scaleX = canvas.width / drawingWidth;
                    const scaleY = canvas.height / drawingHeight;
                    const scale = Math.min(scaleX, scaleY) * 0.95;
                    const newLength = params.length * scale;
                    const newStartX = (canvas.width - (drawingWidth * scale)) / 2 - (drawingBounds.minX * scale);
                    const newStartY = (canvas.height - (drawingHeight * scale)) / 2 - (drawingBounds.minY * scale);
                    
                    finalParams = {
                        ...params,
                        length: newLength,
                        startX: newStartX,
                        startY: newStartY,
                        systemString: newString
                    };
                } else {
                     finalParams = { ...params, systemString: newString };
                }
                lastDrawParams = finalParams;
                renderLSystem(finalParams);
            }

            // --- Event Handlers ---
            const getDrawParameters = () => ({
                length: parseInt(lengthInput.value, 10),
                startX: canvas.width * (parseFloat(startXInput.value) / 100),
                startY: canvas.height * (parseFloat(startYInput.value) / 100),
                startAngle: parseFloat(startAngleInput.value) * (Math.PI / 180),
                turnAngle: parseInt(angleInput.value, 10) * (Math.PI / 180),
                lineColor: lineColorInput.value,
                shapeColor: shapeColorInput.value
            });

            generateBtn.addEventListener('click', () => {
                generateAndDraw();
            });

            fitBtn.addEventListener('click', () => {
                if (!currentSystemString) return;
                const bounds = getDrawingBounds(currentSystemString);
                if (!bounds) return;
                const drawingWidth = bounds.maxX - bounds.minX;
                const drawingHeight = bounds.maxY - bounds.minY;
                if (drawingWidth === 0 || drawingHeight === 0) return;
                const scaleX = canvas.width / drawingWidth;
                const scaleY = canvas.height / drawingHeight;
                const scale = Math.min(scaleX, scaleY) * 0.95;
                const newLength = scale;
                const newStartX = (canvas.width - (drawingWidth * scale)) / 2 - (bounds.minX * scale);
                const newStartY = (canvas.height - (drawingHeight * scale)) / 2 - (bounds.minY * scale);
                
                const currentParams = getDrawParameters();
                const params = {
                    ...currentParams,
                    length: newLength,
                    startX: newStartX,
                    startY: newStartY,
                    systemString: currentSystemString
                };
                lastDrawParams = params;
                renderLSystem(lastDrawParams);
            });

            clearBtn.addEventListener('click', () => {
                currentSystemString = '';
                lastDrawParams = {};
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                outputStringEl.textContent = 'Canvas cleared.';
            });
            
            // --- UI Updaters ---
            const setupSliderSync = (slider, numberInput) => {
                slider.addEventListener('input', () => {
                    numberInput.value = slider.value;
                    handleAutoGenerate();
                });
                numberInput.addEventListener('input', () => {
                    slider.value = numberInput.value;
                    handleAutoGenerate();
                });
            };

            setupSliderSync(iterationsInput, iterationsNumber);
            setupSliderSync(angleInput, angleNumber);
            setupSliderSync(lengthInput, lengthNumber);
            
            [startXInput, startYInput, startAngleInput, lineColorInput, shapeColorInput].forEach(input => {
                input.addEventListener('input', handleAutoGenerate);
            });
            
            startXValue.textContent = startXInput.value;
            startYValue.textContent = startYInput.value;
            startAngleValue.textContent = startAngleInput.value;
            startXInput.addEventListener('input', (e) => startXValue.textContent = e.target.value);
            startYInput.addEventListener('input', (e) => startYValue.textContent = e.target.value);
            startAngleInput.addEventListener('input', (e) => startAngleValue.textContent = e.target.value);
            
            // --- Collapsible Sections ---
            document.querySelectorAll('.collapsible-header').forEach(header => {
                header.addEventListener('click', () => {
                    const content = header.nextElementSibling;
                    const arrow = header.querySelector('.collapsible-arrow');
                    if (content.style.display === 'block') {
                        content.style.display = 'none';
                        arrow.style.transform = 'rotate(0deg)';
                    } else {
                        content.style.display = 'block';
                        arrow.style.transform = 'rotate(180deg)';
                    }
                });
            });

            // --- Color Reset ---
            document.querySelectorAll('.reset-color-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const targetInput = document.getElementById(button.dataset.target);
                    targetInput.value = button.dataset.default;
                    handleAutoGenerate();
                });
            });

            // --- Canvas Sizing and Rendering ---
            function resizeCanvas() {
                const container = canvas.parentElement;
                const size = container.clientWidth; 
                canvas.width = size;
                canvas.height = container.clientHeight - (container.querySelector('.p-4').offsetHeight);
                if (Object.keys(lastDrawParams).length > 0) {
                    renderLSystem(lastDrawParams); 
                }
            }
            
            const resizeObserver = new ResizeObserver(() => {
                resizeCanvas();
            });
            resizeObserver.observe(canvas.parentElement);
            
            // --- Preset Loading Logic ---
            function loadPreset(presetName) {
                const preset = presets[presetName];
                if (!preset) {
                    // Clear all for 'custom' option
                    createAxiomDisplay('');
                    ruleListContainer.innerHTML = '';
                    iterationsInput.value = 5;
                    iterationsNumber.value = 5;
                    angleInput.value = 25;
                    angleNumber.value = 25;
                    lengthInput.value = 5;
                    lengthNumber.value = 5;
                    startXInput.value = 50;
                    startYInput.value = 100;
                    startAngleInput.value = -90;
                    startXValue.textContent = 50;
                    startYValue.textContent = 100;
                    startAngleValue.textContent = -90;
                    lineColorInput.value = '#1e2b3b';
                    shapeColorInput.value = '#ef4444';
                    return;
                }

                // Update UI from preset data
                createAxiomDisplay(preset.axiom);
                ruleListContainer.innerHTML = '';
                preset.rules.forEach((rule, index) => {
                    createRuleDisplay(`rule-${index}`, rule.variable, rule.body);
                });
                iterationsInput.value = preset.settings.iterations;
                iterationsNumber.value = preset.settings.iterations;
                angleInput.value = preset.settings.angle;
                angleNumber.value = preset.settings.angle;
                lengthInput.value = preset.settings.length;
                lengthNumber.value = preset.settings.length;
                startXInput.value = preset.settings.startX;
                startYInput.value = preset.settings.startY;
                startAngleInput.value = preset.settings.startAngle;
                startXValue.textContent = preset.settings.startX;
                startYValue.textContent = preset.settings.startY;
                startAngleValue.textContent = preset.settings.startAngle;
                lineColorInput.value = preset.settings.lineColor;
                shapeColorInput.value = preset.settings.shapeColor;

                handleAutoGenerate();
            }

            presetSelect.addEventListener('change', (e) => {
                loadPreset(e.target.value);
            });
            
            homeBtn.addEventListener('click', () => {
                window.location.href = "/kwerky.html";
            });

            // --- Initial Setup ---
            function init() {
                loadPreset('simple-tree');
            }
            
            init();
        });
    </script>
</body>
</html>

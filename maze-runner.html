<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Runner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrollbars from flashing during generation */
        }
        canvas {
            background-color: #1a202c; /* dark gray */
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .control-panel {
            background-color: #2d3748; /* gray-800 */
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center h-screen">

    <div id="main-container" class="w-full max-w-4xl p-4">
        <div class="flex justify-between items-center mb-4">
            <a href="/kwerky.html" class="p-2 rounded-full hover:bg-gray-700 transition-colors" aria-label="Go to Home">
                <svg xmlns="http://www.w3.org/2000/svg" height="32px" viewBox="0 0 24 24" width="32px" class="fill-current text-white">
                    <path d="M0 0h24v24H0V0z" fill="none"/>
                    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8h5z"/>
                </svg>
            </a>
            <h1 class="text-4xl font-bold text-center text-cyan-400 flex-grow">Maze Runner</h1>
            <div class="w-12"></div> <!-- Spacer to keep title centered -->
        </div>
        
        <!-- Game Canvas -->
        <div class="relative w-full aspect-[4/3]">
             <canvas id="game-canvas" class="w-full h-full"></canvas>
        </div>

        <!-- Controls -->
        <div class="control-panel grid grid-cols-2 sm:grid-cols-5 gap-4 items-center mt-4">
            <div id="timer" class="text-2xl font-mono bg-gray-900 p-3 rounded-lg text-center col-span-2 sm:col-span-1">
                Time: 0.00s
            </div>
            <select id="difficulty" class="bg-gray-700 border border-gray-600 rounded-lg p-3 text-lg focus:ring-cyan-500 focus:border-cyan-500 w-full">
                <option value="0">Easy</option>
                <option value="1">Standard</option>
                <option value="2">Hard</option>
            </select>
            <button id="solution-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg text-lg transition-transform transform hover:scale-105 w-full">
                Solve
            </button>
            <button id="pause-button" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-4 rounded-lg text-lg transition-transform transform hover:scale-105 w-full">
                Pause
            </button>
            <button id="start-button" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-4 rounded-lg text-lg transition-transform transform hover:scale-105 w-full">
                Start Game
            </button>
        </div>
    </div>

    <!-- Win Modal -->
    <div id="win-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg p-8 shadow-2xl text-center transform transition-all scale-95 opacity-0" id="win-modal-content">
            <h2 class="text-4xl font-bold text-green-400 mb-4">You Win!</h2>
            <p class="text-2xl mb-6" id="final-time"></p>
            <button id="play-again-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-lg transition-transform transform hover:scale-105">
                Play Again
            </button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const timerEl = document.getElementById('timer');
        const difficultySelect = document.getElementById('difficulty');
        const startButton = document.getElementById('start-button');
        const pauseButton = document.getElementById('pause-button');
        const solutionButton = document.getElementById('solution-button');
        const winModal = document.getElementById('win-modal');
        const winModalContent = document.getElementById('win-modal-content');
        const finalTimeEl = document.getElementById('final-time');
        const playAgainButton = document.getElementById('play-again-button');

        // --- Game State ---
        let maze, player, goal;
        let activeCellSize = 20;
        let mazeWidth, mazeHeight;
        let gameState = 'waiting'; // 'waiting', 'playing', 'paused', 'finished', 'generating'
        let solutionPath = null;
        
        // --- Timer State ---
        let timerInterval;
        let startTime;
        let elapsedTime = 0; // Time in ms, excluding pauses

        // --- Player Physics ---
        const playerProps = {
            vx: 0,
            vy: 0,
            speed: 0.3,
            maxSpeed: 3,
            friction: 0.95,
            color: '#38bdf8', // light blue
        };

        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false
        };

        // --- Event Listeners ---
        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                e.preventDefault();
                if (gameState === 'playing') keys[e.key] = true;
            }
        });
        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                e.preventDefault();
                keys[e.key] = false;
            }
        });

        startButton.addEventListener('click', () => {
            if (gameState === 'playing' || gameState === 'paused' || gameState === 'finished') {
                resetToWelcome();
            } else {
                startGame();
            }
        });

        pauseButton.addEventListener('click', togglePause);
        solutionButton.addEventListener('click', showSolution);
        playAgainButton.addEventListener('click', resetToWelcome);
        
        window.addEventListener('resize', resizeCanvas);

        // --- Initial Setup ---
        function initialize() {
            resizeCanvas();
            drawWelcomeMessage();
            pauseButton.disabled = true;
            solutionButton.disabled = true;
        }
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            if (gameState !== 'waiting' && gameState !== 'generating') {
                activeCellSize = Math.min(canvas.width / mazeWidth, canvas.height / mazeHeight);
                draw();
            } else {
                drawWelcomeMessage();
            }
        }
        
        function drawWelcomeMessage() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = `bold ${canvas.width / 25}px Inter`;
            ctx.textAlign = 'center';
            ctx.fillText('Select difficulty and press Start!', canvas.width / 2, canvas.height / 2);
        }
        
        function resetToWelcome() {
            hideWinModal();
            gameState = 'waiting';
            startButton.textContent = 'Start Game';
            difficultySelect.disabled = false;
            pauseButton.disabled = true;
            solutionButton.disabled = true;
            solutionPath = null;
            resetTimer();
            drawWelcomeMessage();
        }

        function startGame() {
            startButton.disabled = true;
            difficultySelect.disabled = true;
            startButton.textContent = 'Generating...';
            gameState = 'generating';
            solutionPath = null;
            
            setTimeout(() => {
                const difficulty = difficultySelect.value;
                if (difficulty === '0') { // Easy
                    activeCellSize = 40;
                } else if (difficulty === '1') { // Standard
                    activeCellSize = 30;
                } else { // Hard
                    activeCellSize = 20;
                }

                mazeWidth = Math.floor(canvas.width / activeCellSize);
                mazeHeight = Math.floor(canvas.height / activeCellSize);
                
                if (difficulty === '2') {
                    maze = generateWilsonsMaze(mazeWidth, mazeHeight);
                } else {
                    maze = generateStandardMaze(mazeWidth, mazeHeight);
                }

                player = {
                    x: activeCellSize / 2,
                    y: activeCellSize / 2,
                    ...playerProps,
                    size: activeCellSize / 2.5
                };

                goal = {
                    x: (mazeWidth - 1) * activeCellSize + activeCellSize / 2,
                    y: (mazeHeight - 1) * activeCellSize + activeCellSize / 2,
                    size: activeCellSize / 2,
                    color: '#4ade80'
                };

                resetTimer();
                startTimer();
                gameState = 'playing';
                
                startButton.disabled = false;
                pauseButton.disabled = false;
                solutionButton.disabled = false;
                pauseButton.textContent = 'Pause';
                startButton.textContent = 'Restart Game';
                gameLoop();
            }, 50);
        }
        
        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
                pauseTimer();
                pauseButton.textContent = 'Resume';
                drawPauseOverlay();
            } else if (gameState === 'paused') {
                gameState = 'playing';
                startTimer();
                pauseButton.textContent = 'Pause';
                gameLoop();
            }
        }
        
        function showSolution() {
            if (gameState !== 'playing' && gameState !== 'paused') return;
            if (!solutionPath) {
                solutionPath = findSolution();
            }
            solutionButton.disabled = true;
            draw();
        }

        // --- Maze Generation ---
        function generateStandardMaze(width, height) {
            let grid = Array.from({ length: height }, () => Array.from({ length: width }, () => ({ walls: { top: true, right: true, bottom: true, left: true }, visited: false })));
            let stack = [], current = { x: 0, y: 0 };
            grid[0][0].visited = true;
            function findNewStart() { for (let y = 0; y < height; y++) for (let x = 0; x < width; x++) if (!grid[y][x].visited) return { x, y }; return null; }
            while (true) {
                let { x, y } = current;
                let neighbors = [];
                if (y > 0 && !grid[y - 1][x].visited) neighbors.push({ x, y: y - 1, dir: 'top' });
                if (x < width - 1 && !grid[y][x + 1].visited) neighbors.push({ x: x + 1, y, dir: 'right' });
                if (y < height - 1 && !grid[y + 1][x].visited) neighbors.push({ x, y: y + 1, dir: 'bottom' });
                if (x > 0 && !grid[y][x - 1].visited) neighbors.push({ x: x - 1, y, dir: 'left' });
                if (neighbors.length > 0) {
                    let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    stack.push(current);
                    if (next.dir === 'top') { grid[y][x].walls.top = false; grid[next.y][next.x].walls.bottom = false; }
                    else if (next.dir === 'right') { grid[y][x].walls.right = false; grid[next.y][next.x].walls.left = false; }
                    else if (next.dir === 'bottom') { grid[y][x].walls.bottom = false; grid[next.y][next.x].walls.top = false; }
                    else if (next.dir === 'left') { grid[y][x].walls.left = false; grid[next.y][next.x].walls.right = false; }
                    current = { x: next.x, y: next.y };
                    grid[current.y][current.x].visited = true;
                } else if (stack.length > 0) {
                    current = stack.pop();
                } else {
                    current = findNewStart();
                    if (current === null) break;
                    grid[current.y][current.x].visited = true;
                }
            }
            return grid;
        }

        function generateWilsonsMaze(width, height) {
            let grid = Array.from({ length: height }, () => Array.from({ length: width }, () => ({ walls: { top: true, right: true, bottom: true, left: true }, inMaze: false })));
            const unvisited = [];
            for (let y = 0; y < height; y++) for (let x = 0; x < width; x++) unvisited.push({ x, y });
            const firstCell = unvisited.splice(Math.floor(Math.random() * unvisited.length), 1)[0];
            grid[firstCell.y][firstCell.x].inMaze = true;
            while (unvisited.length > 0) {
                let current = unvisited[Math.floor(Math.random() * unvisited.length)];
                let walkPath = [{...current}];
                while (!grid[current.y][current.x].inMaze) {
                    let neighbors = [];
                    const { x, y } = current;
                    if (y > 0) neighbors.push({ x, y: y - 1 });
                    if (x < width - 1) neighbors.push({ x: x + 1, y });
                    if (y < height - 1) neighbors.push({ x, y: y + 1 });
                    if (x > 0) neighbors.push({ x: x - 1, y });
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    const existingIndex = walkPath.findIndex(p => p.x === next.x && p.y === next.y);
                    if (existingIndex !== -1) {
                        walkPath = walkPath.slice(0, existingIndex + 1);
                    } else {
                        walkPath.push(next);
                    }
                    current = next;
                }
                for (let i = 0; i < walkPath.length - 1; i++) {
                    const p1 = walkPath[i], p2 = walkPath[i+1];
                    if (p2.y < p1.y) { grid[p1.y][p1.x].walls.top = false; grid[p2.y][p2.x].walls.bottom = false; }
                    else if (p2.x > p1.x) { grid[p1.y][p1.x].walls.right = false; grid[p2.y][p2.x].walls.left = false; }
                    else if (p2.y > p1.y) { grid[p1.y][p1.x].walls.bottom = false; grid[p2.y][p2.x].walls.top = false; }
                    else if (p2.x < p1.x) { grid[p1.y][p1.x].walls.left = false; grid[p2.y][p2.x].walls.right = false; }
                }
                for (const cell of walkPath) {
                    grid[cell.y][cell.x].inMaze = true;
                    const index = unvisited.findIndex(u => u.x === cell.x && u.y === cell.y);
                    if (index !== -1) unvisited.splice(index, 1);
                }
            }
            return grid;
        }
        
        function findSolution() {
            const startNode = { x: 0, y: 0, g: 0, h: 0, f: 0, parent: null };
            const endNode = { x: mazeWidth - 1, y: mazeHeight - 1 };
            let openSet = [startNode], closedSet = [];
            function heuristic(a, b) { return Math.abs(a.x - b.x) + Math.abs(a.y - b.y); }
            while(openSet.length > 0) {
                let lowestIndex = 0;
                for(let i = 0; i < openSet.length; i++) if(openSet[i].f < openSet[lowestIndex].f) lowestIndex = i;
                let current = openSet[lowestIndex];
                if(current.x === endNode.x && current.y === endNode.y) {
                    let path = [];
                    let temp = current;
                    while(temp) { path.push(temp); temp = temp.parent; }
                    return path.reverse();
                }
                openSet.splice(lowestIndex, 1);
                closedSet.push(current);
                let neighbors = [];
                const {x, y} = current, cell = maze[y][x];
                if(!cell.walls.top) neighbors.push({x, y: y - 1});
                if(!cell.walls.right) neighbors.push({x: x + 1, y});
                if(!cell.walls.bottom) neighbors.push({x, y: y + 1});
                if(!cell.walls.left) neighbors.push({x: x - 1, y});
                for(let neighbor of neighbors) {
                    if(closedSet.find(node => node.x === neighbor.x && node.y === neighbor.y)) continue;
                    let gScore = current.g + 1;
                    let existingNode = openSet.find(node => node.x === neighbor.x && node.y === neighbor.y);
                    if(!existingNode) {
                        let newNode = { ...neighbor, g: gScore, h: heuristic(neighbor, endNode), f: gScore + heuristic(neighbor, endNode), parent: current };
                        openSet.push(newNode);
                    } else if (gScore < existingNode.g) {
                        existingNode.g = gScore;
                        existingNode.f = gScore + existingNode.h;
                        existingNode.parent = current;
                    }
                }
            }
            return [];
        }

        // --- Game Loop and Physics ---
        function gameLoop() {
            if (gameState !== 'playing') return;
            updatePlayer();
            draw();
            checkWinCondition();
            requestAnimationFrame(gameLoop);
        }

        function updatePlayer() {
            if (keys.ArrowUp) player.vy -= player.speed;
            if (keys.ArrowDown) player.vy += player.speed;
            if (keys.ArrowLeft) player.vx -= player.speed;
            if (keys.ArrowRight) player.vx += player.speed;
            player.vy *= player.friction;
            player.vx *= player.friction;
            player.vx = Math.max(-player.maxSpeed, Math.min(player.maxSpeed, player.vx));
            player.vy = Math.max(-player.maxSpeed, Math.min(player.maxSpeed, player.vy));
            const r = player.size / 2;
            const wallThickness = 2;
            let nextX = player.x + player.vx;
            let gridYTop = Math.floor((player.y - r) / activeCellSize);
            let gridYBottom = Math.floor((player.y + r) / activeCellSize);
            if (player.vx > 0) {
                let gridX = Math.floor((nextX + r) / activeCellSize);
                if ((maze[gridYTop]?.[gridX - 1]?.walls.right) || (maze[gridYBottom]?.[gridX - 1]?.walls.right)) {
                    player.x = gridX * activeCellSize - r - wallThickness;
                    player.vx = 0;
                } else {
                    player.x = nextX;
                }
            } else if (player.vx < 0) {
                let gridX = Math.floor((nextX - r) / activeCellSize);
                 if ((maze[gridYTop]?.[gridX]?.walls.left) || (maze[gridYBottom]?.[gridX]?.walls.left)) {
                    player.x = (gridX + 1) * activeCellSize + r + wallThickness;
                    player.vx = 0;
                } else {
                    player.x = nextX;
                }
            }
            let nextY = player.y + player.vy;
            let gridXLeft = Math.floor((player.x - r) / activeCellSize);
            let gridXRight = Math.floor((player.x + r) / activeCellSize);
            if (player.vy > 0) {
                let gridY = Math.floor((nextY + r) / activeCellSize);
                if ((maze[gridY - 1]?.[gridXLeft]?.walls.bottom) || (maze[gridY - 1]?.[gridXRight]?.walls.bottom)) {
                    player.y = gridY * activeCellSize - r - wallThickness;
                    player.vy = 0;
                } else {
                    player.y = nextY;
                }
            } else if (player.vy < 0) {
                let gridY = Math.floor((nextY - r) / activeCellSize);
                if ((maze[gridY]?.[gridXLeft]?.walls.top) || (maze[gridY]?.[gridXRight]?.walls.top)) {
                    player.y = (gridY + 1) * activeCellSize + r + wallThickness;
                    player.vy = 0;
                } else {
                    player.y = nextY;
                }
            }
        }


        function checkWinCondition() {
            const dist = Math.hypot(player.x - goal.x, player.y - goal.y);
            if (dist < player.size / 2 + goal.size / 2) {
                gameState = 'finished';
                stopTimer();
                showWinModal();
                pauseButton.disabled = true;
                solutionButton.disabled = true;
            }
        }

        // --- Drawing ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMaze();
            if (solutionPath) drawSolution();
            drawGoal();
            drawPlayer();
        }

        function drawPauseOverlay() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = `bold ${canvas.width / 15}px Inter`;
            ctx.textAlign = 'center';
            ctx.fillText('Paused', canvas.width / 2, canvas.height / 2);
        }

        function drawMaze() {
            ctx.strokeStyle = '#475569';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    const cell = maze[y][x];
                    const xPos = x * activeCellSize, yPos = y * activeCellSize;
                    if (cell.walls.top) { ctx.moveTo(xPos, yPos); ctx.lineTo(xPos + activeCellSize, yPos); }
                    if (cell.walls.right) { ctx.moveTo(xPos + activeCellSize, yPos); ctx.lineTo(xPos + activeCellSize, yPos + activeCellSize); }
                    if (cell.walls.bottom) { ctx.moveTo(xPos + activeCellSize, yPos + activeCellSize); ctx.lineTo(xPos, yPos + activeCellSize); }
                    if (cell.walls.left) { ctx.moveTo(xPos, yPos + activeCellSize); ctx.lineTo(xPos, yPos); }
                }
            }
            ctx.stroke();
        }
        
        function drawSolution() {
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
            ctx.lineWidth = activeCellSize / 4;
            ctx.beginPath();
            for (let i = 0; i < solutionPath.length; i++) {
                const x = solutionPath[i].x * activeCellSize + activeCellSize / 2;
                const y = solutionPath[i].y * activeCellSize + activeCellSize / 2;
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        }

        function drawPlayer() { ctx.fillStyle = player.color; ctx.beginPath(); ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2); ctx.fill(); }
        function drawGoal() { ctx.fillStyle = goal.color; ctx.beginPath(); ctx.arc(goal.x, goal.y, goal.size, 0, Math.PI * 2); ctx.fill(); }

        // --- Timer ---
        function resetTimer() { clearInterval(timerInterval); elapsedTime = 0; timerEl.textContent = 'Time: 0.00s'; }
        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(() => {
                const currentSegmentTime = Date.now() - startTime;
                const totalTime = elapsedTime + currentSegmentTime;
                timerEl.textContent = `Time: ${(totalTime / 1000).toFixed(2)}s`;
            }, 100);
        }
        function pauseTimer() { clearInterval(timerInterval); elapsedTime += Date.now() - startTime; }
        function stopTimer() { clearInterval(timerInterval); elapsedTime += Date.now() - startTime; finalTimeEl.textContent = `Your time: ${(elapsedTime / 1000).toFixed(2)}s`; }

        // --- Modal ---
        function showWinModal() {
            winModal.classList.remove('hidden');
            setTimeout(() => { winModalContent.classList.add('scale-100', 'opacity-100'); winModalContent.classList.remove('scale-95', 'opacity-0'); }, 10);
        }
        function hideWinModal() {
            winModalContent.classList.remove('scale-100', 'opacity-100'); winModalContent.classList.add('scale-95', 'opacity-0');
            setTimeout(() => { winModal.classList.add('hidden'); }, 200);
        }
        
        // --- Run on Load ---
        initialize();

    </script>
</body>
</html>
